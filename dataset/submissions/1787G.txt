#include <bits/stdc++.h>
 using i64 = long long;
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, q;
    std::cin >> n >> q;
        std::vector<std::vector<std::tuple<int, int, int>>> adj(n);
    for (int i = 1; i < n; i++) {
        int u, v, w, c;
        std::cin >> u >> v >> w >> c;
        u--, v--, c--;
                adj[u].emplace_back(v, w, c);
        adj[v].emplace_back(u, w, c);
    }
        std::vector<int> parent(n, -1), col(n), cntend(n), cnt(n);
    std::vector<i64> weight(n);
    std::vector<bool> bad(n);
    auto dfs = [&](auto self, int x) -> void {
        for (auto [y, w, c] : adj[x]) {
            if (y == parent[x]) continue;
            weight[c] += w;
            col[y] = c;
            parent[y] = x;
            self(self, y);
        }
        for (auto [y, w, c] : adj[x]) {
            cnt[c]++;
            if (cnt[c] > 2) bad[c] = true;
        }
        for (auto [y, w, c] : adj[x]) {
            if (cnt[c] == 1) {
                cntend[c]++;
            }
            cnt[c] = 0;
        }
    };
    dfs(dfs, 0);
        for (int i = 0; i < n; i++) {
        if (cntend[i] != 2) {
            bad[i] = true;
        }
    }
        std::vector<int> lca(n, -1);
        for (int i = 1; i < n; i++) {
        if (!bad[col[i]] && lca[col[i]] == -1) {
            int j = i;
            while (j > 0 && col[j] == col[i]) {
                j = parent[j];
            }
            lca[col[i]] = j;
        }
    }
        std::vector<std::multiset<i64>> s(n);
    for (int i = 0; i < n; i++) {
        if (!bad[i]) {
            s[lca[i]].insert(weight[i]);
            // std::cerr << i+ 1<< " " << lca[i] + 1 << " " << weight[i] << "\n";
        }
    }
    for (int i = 0; i < n; i++) {
        s[i].insert(0);
    }
        std::multiset<i64> as{0};
        std::vector<int> ban(n);
    for (int i = 0; i < n; i++) {
        as.insert(*s[i].rbegin());
    }
        std::vector<bool> good(n, true);
        while (q--) {
        int o, x;
        std::cin >> o >> x;
        x--;
                if (o == 0) {
            good[x] = false;
            as.erase(as.find(*s[x].rbegin()));
            if (x > 0 && !bad[col[x]]) {
                if (ban[col[x]]++ == 0) {
                    int l = lca[col[x]];
                    if (good[l]) {
                        as.erase(as.find(*s[l].rbegin()));
                    }
                    s[l].erase(s[l].find(weight[col[x]]));
                    if (good[l]) {
                        as.insert(*s[l].rbegin());
                    }
                }
            }
        } else {
            good[x] = true;
            as.insert(*s[x].rbegin());
            if (x > 0 && !bad[col[x]]) {
                if (--ban[col[x]] == 0) {
                    int l = lca[col[x]];
                    if (good[l]) {
                        as.erase(as.find(*s[l].rbegin()));
                    }
                    s[l].insert(weight[col[x]]);
                    if (good[l]) {
                        as.insert(*s[l].rbegin());
                    }
                }
            }
        }
                auto ans = *as.rbegin();
        std::cout << ans << "\n";
    }
        return 0;
}