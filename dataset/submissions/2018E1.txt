#include <bits/stdc++.h>
 using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
struct DSU {
    std::vector<int> f, siz;
        DSU() {}
    DSU(int n) {
        init(n);
    }
        void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
        int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
        bool same(int x, int y) {
        return find(x) == find(y);
    }
        bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
        int size(int x) {
        return siz[find(x)];
    }
};
void solve() {
    int n;
    std::cin >> n;
        std::vector<int> l(n), r(n);
    for (int i = 0; i < n; i++) {
        std::cin >> l[i];
        l[i]--;
    }
    for (int i = 0; i < n; i++) {
        std::cin >> r[i];
        r[i]--;
    }
        std::vector<int> ans(n + 1);
        std::vector<int> ord(n);
    std::iota(ord.begin(), ord.end(), 0);
    std::sort(ord.begin(), ord.end(),
        [&](int i, int j) {
            return r[i] < r[j];
        });
        DSU dsu(2 * n);
    std::vector<int> L(2 * n, -1), d(2 * n);
    auto get = [&](int k) {
        dsu.init(2 * n);
        int left = 0;
        int ans = 0;
        int cur = 0;
        int p = -1;
        int fp = 0;
        for (auto i : ord) {
            if (l[i] < left) {
                continue;
            }
            if (r[i] > p) {
                for (int j = std::max(p + 1, left); j < r[i]; j++) {
                    dsu.merge(r[i], j);
                }
                L[r[i]] = p;
                p = r[i];
                d[r[i]] = fp;
                fp = 0;
            }
            int j = dsu.find(l[i]);
            d[j]--;
            while (L[j] != -1 && d[j] <= 0) {
                int x = L[j];
                dsu.merge(j, x);
                L[j] = L[x];
                d[j] += d[x];
            }
            if (L[j] == -1) {
                cur += -d[j];
                d[j] = 0;
            }
            fp++;
            if (cur == k) {
                ans++;
                cur = 0;
                left = p + 1;
                p = -1;
                fp = 0;
            }
        }
        return ans;
    };
        auto work = [&](auto &self, int l, int r, int vl, int vr) -> void {
        if (l > r) {
            return;
        }
        if (vl == vr) {
            for (int i = l; i <= r; i++) {
                ans[i] = vl;
            }
            return;
        }
        int m = (l + r) / 2;
        int v = get(m);
        ans[m] = v;
        self(self, l, m - 1, vl, v);
        self(self, m + 1, r, v, vr);
    };
    work(work, 1, n, n, 0);
        int mx = 0;
    for (int i = 1; i <= n; i++) {
        mx = std::max(mx, ans[i] * i);
    }
    std::cout << mx << "\n";
}
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int t;
    std::cin >> t;
        while (t--) {
        solve();
    }
        return 0;
}