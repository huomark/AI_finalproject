#include <bits/stdc++.h>
 using i64 = long long;
 constexpr int dx[] = {-1, 1, 0, 0};
constexpr int dy[] = {0, 0, -1, 1};
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, m, k;
    std::cin >> n >> m >> k;
        std::vector<std::string> s(n);
    for (int i = 0; i < n; i++) {
        std::cin >> s[i];
    }
        std::vector vis(n, std::vector<bool>(m));
        std::vector<int> vx{0, n + 1}, vy{0, m};
    std::vector<std::array<int, 4>> rec;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (s[i][j] == '.' || vis[i][j]) {
                continue;
            }
            std::queue<std::pair<int, int>> q;
            q.emplace(i, j);
            vis[i][j] = true;
            int L = j, R = j, U = i, D = i;
            while (!q.empty()) {
                auto [x, y] = q.front();
                q.pop();
                                L = std::min(L, y);
                R = std::max(R, y + 1);
                U = std::min(U, x);
                D = std::max(D, x + 1);
                                for (int k = 0; k < 4; k++) {
                    int nx = x + dx[k];
                    int ny = y + dy[k];
                    if (0 <= nx && nx < n && 0 <= ny && ny < m && s[nx][ny] == '*' && !vis[nx][ny]) {
                        vis[nx][ny] = true;
                        q.emplace(nx, ny);
                    }
                }
            }
            rec.push_back({U, D, L, R});
            if (U) {
                vx.push_back(U - 1);
            }
            vx.push_back(U);
            vx.push_back(U + 1);
            vx.push_back(D - 1);
            vx.push_back(D);
            if (D < n) {
                vx.push_back(D - 1);
            }
            vy.push_back(L);
            vy.push_back(R);
        }
    }
        std::sort(vx.begin(), vx.end());
    std::sort(vy.begin(), vy.end());
    vx.erase(std::unique(vx.begin(), vx.end()), vx.end());
    vy.erase(std::unique(vy.begin(), vy.end()), vy.end());
        for (auto &[U, D, L, R] : rec) {
        U = std::lower_bound(vx.begin(), vx.end(), U) - vx.begin();
        D = std::lower_bound(vx.begin(), vx.end(), D) - vx.begin();
        L = std::lower_bound(vy.begin(), vy.end(), L) - vy.begin();
        R = std::lower_bound(vy.begin(), vy.end(), R) - vy.begin();
    }
        i64 ans = 0;
    for (int u = 0; u + 1 < vx.size(); u++) {
        for (int d = u + 1; d + 1 < vx.size(); d++) {
            std::vector<int> ord;
            for (int i = 0; i < k; i++) {
                if (rec[i][0] < d && u < rec[i][1]) {
                    ord.push_back(i);
                }
            }
            std::sort(ord.begin(), ord.end(), [&](int i, int j) {
                return rec[i][2] < rec[j][2];
            });
            int mx = 0;
            for (int i = 0; i < ord.size(); i++) {
                int x = ord[i];
                if (rec[x][2] >= mx) {
                    int mmx = 0;
                    for (int j = i; j <= i + 2 && j < ord.size(); j++) {
                        int y = ord[j];
                        auto [U, D, L, R] = rec[y];
                        mmx = std::max(mmx, R);
                        if (U < u || D > d) {
                            break;
                        }
                        int lim = vy.size() - 1;
                        if (j + 1 < ord.size()) {
                            lim = rec[ord[j + 1]][2];
                        }
                        if (mmx > lim) {
                            continue;
                        }
                        ans += 1LL * (vx[u + 1] - vx[u]) * (vx[d + 1] - vx[d])
                            * (vy[rec[x][2]] - vy[mx] + 1) * (vy[lim] - vy[mmx] + 1);
                    }
                }
                mx = std::max(mx, rec[x][3]);
            }
        }
    }
        std::cout << ans << "\n";
        return 0;
}