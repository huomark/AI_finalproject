#include <bits/stdc++.h>
 using i64 = long long;
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, k;
    std::cin >> n >> k;
        if (k % 2 != 0) {
        std::cout << -1 << "\n";
        return 0;
    }
        std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
        a[i]--;
    }
        auto get = [&]() {
        std::vector f(2, std::vector(3, std::vector<int>(n, -1)));
        std::vector p(2, std::vector(3, std::vector(20, std::vector<int>(n, -1))));
        std::vector<int> lst(n, -1);
        for (int i = 0; i < n; i++) {
            for (int x = 0; x < 3; x++) {
                int y = a[i] - 1 + x;
                if (y >= 0 && y < n) {
                    f[0][x][i] = lst[y];
                }
            }
            lst[a[i]] = i;
        }
        lst.assign(n, -1);
        for (int i = n - 1; i >= 0; i--) {
            for (int x = 0; x < 3; x++) {
                int y = a[i] - 1 + x;
                if (y >= 0 && y < n) {
                    f[1][x][i] = lst[y];
                }
            }
            lst[a[i]] = i;
        }
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 3; y++) {
                p[x][y][0] = f[x][y];
                for (int i = 0; i < 19; i++) {
                    for (int j = 0; j < n; j++) {
                        if (p[x][y][i][j] != -1) {
                            p[x][y][i + 1][j] = p[x][y][i][p[x][y][i][j]];
                        }
                    }
                }
            }
        }
                int ans = n;
                auto get = [&](int s, int x, int y, int k) {
            if (k == 0) {
                return s;
            }
            for (int i = std::__lg(k); i >= 0; i--) {
                if (k >> i & 1) {
                    if (s != -1) {
                        s = p[x][y][i][s];
                    }
                }
            }
            if (x == 1 && s == -1) {
                s = n;
            }
            return s;
        };
                if (k >= 4) {
            for (int x = 0; x < n; x++) {
                int y = f[1][2][x];
                int z = f[0][2][x];
                int w = f[1][1][x];
                if (y == -1 || z == -1 || w == -1) {
                    continue;
                }
                int t = (k - 4) / 2;
                                int j = *std::ranges::partition_point(std::ranges::iota_view(0, t),
                    [&](int v) {
                        return get(x, 0, 0, v) > get(z, 0, 2, t - v);
                    });
                int L = -1;
                for (auto v : {j, j - 1}) {
                    if (0 <= v && v <= t) {
                        L = std::max(L, std::min(get(x, 0, 0, v), get(z, 0, 2, t - v)));
                    }
                }
                j = *std::ranges::partition_point(std::ranges::iota_view(0, t),
                    [&](int v) {
                        return get(w, 1, 0, v) < get(y, 1, 2, t - v);
                    });
                int R = n;
                for (auto v : {j, j - 1}) {
                    if (0 <= v && v <= t) {
                        R = std::min(R, std::max(get(w, 1, 0, v), get(y, 1, 2, t - v)));
                    }
                }
                if (L != -1 && R != n) {
                    ans = std::min(ans, R - L);
                }
            }
        }
        for (int x = 0; x < n; x++) {
            int y = f[1][1][x];
            if (y == -1) {
                continue;
            }
            int t = (k - 2) / 2;
            int L = get(x, 0, 2, t);
            int j = *std::ranges::partition_point(std::ranges::iota_view(0, t),
                [&](int v) {
                    return get(x, 1, 0, v) < get(y, 1, 2, t - v);
                });
            int R = n;
            for (auto v : {j, j - 1}) {
                if (0 <= v && v <= t) {
                    R = std::min(R, std::max(get(x, 1, 0, v), get(y, 1, 2, t - v)));
                }
            }
            if (L != -1 && R != n) {
                ans = std::min(ans, R - L);
            }
        }
        for (int x = 0; x < n; x++) {
            int y = f[0][1][x];
            if (y == -1) {
                continue;
            }
            int t = (k - 2) / 2;
            int R = get(x, 1, 2, t);
            int j = *std::ranges::partition_point(std::ranges::iota_view(0, t),
                [&](int v) {
                    return get(x, 0, 0, v) > get(y, 0, 2, t - v);
                });
            int L = -1;
            for (auto v : {j, j - 1}) {
                if (0 <= v && v <= t) {
                    L = std::max(L, std::min(get(x, 0, 0, v), get(y, 0, 2, t - v)));
                }
            }
            if (L != -1 && R != n) {
                ans = std::min(ans, R - L);
            }
        }
                return ans;
    };
        auto ans = get();
    for (auto &x : a) {
        x = n - 1 - x;
    }
    ans = std::min(ans, get());
    if (ans == n) {
        ans = -1;
    }
    std::cout << ans << "\n";
        return 0;
}