#include <bits/stdc++.h>
 using i64 = long long;
 const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
 constexpr i64 inf = 1E18;
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, m, p, q;
    std::cin >> n >> m >> p >> q;
        std::vector<std::string> s(n);
    for (int i = 0; i < n; i++) {
        std::cin >> s[i];
    }
        const int N = n * m;
    std::vector<int> match(N, -1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (s[i][j] == 'L') {
                match[i * m + j] = i * m + j + 1;
                match[i * m + j + 1] = i * m + j;
            } else if (s[i][j] == 'U') {
                match[i * m + j] = (i + 1) * m + j;
                match[(i + 1) * m + j] = i * m + j;
            }
        }
    }
        auto bfs = [&](int t) {
        std::vector<i64> dis(N, inf);
        std::queue<std::pair<int, i64>> q1, q2;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if ((i + j) % 2 == t && s[i][j] == '.') {
                    q1.emplace(i * m + j, 0);
                }
            }
        }
                while (!q1.empty() || !q2.empty()) {
            int u;
            i64 d;
                        if (!q1.empty() && (q2.empty() || q1.front().second < q2.front().second)) {
                std::tie(u, d) = q1.front();
                q1.pop();
            } else {
                std::tie(u, d) = q2.front();
                q2.pop();
            }
                        if (dis[u] != inf) {
                continue;
            }
                        dis[u] = d;
            int x = u / m, y = u % m;
                        for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                                if (nx < 0 || nx >= n || ny < 0 || ny >= m || match[nx * m + ny] == -1) {
                    continue;
                }
                                int mx = nx + dx[i];
                int my = ny + dy[i];
                                if (mx < 0 || mx >= n || my < 0 || my >= m || match[nx * m + ny] != mx * m + my) {
                    q1.emplace(match[nx * m + ny], d + p);
                } else {
                    q2.emplace(match[nx * m + ny], d + q);
                }
            }
        }
                return dis;
    };
        auto f0 = bfs(0);
    auto f1 = bfs(1);
        i64 ans = inf;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if ((i + j) % 2 == 0) {
                i64 v = f0[i * m + j];
                if (i) {
                    ans = std::min(ans, v + f1[(i - 1) * m + j]);
                }
                if (i + 1 < n) {
                    ans = std::min(ans, v + f1[(i + 1) * m + j]);
                }
                if (j) {
                    ans = std::min(ans, v + f1[i * m + j - 1]);
                }
                if (j + 1 < m) {
                    ans = std::min(ans, v + f1[i * m + j + 1]);
                }
            }
        }
    }
    if (ans == inf) {
        ans = -1;
    }
    std::cout << ans << "\n";
        return 0;
}