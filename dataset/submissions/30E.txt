#include <bits/stdc++.h>
 using i64 = long long;
struct SAM {
    static constexpr int ALPHABET_SIZE = 26;
    struct Node {
        int len;
        int link;
        std::array<int, ALPHABET_SIZE> next;
        Node() : len{}, link{}, next{} {}
    };
    std::vector<Node> t;
    SAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int extend(int p, int c) {
        if (t[p].next[c]) {
            int q = t[p].next[c];
            if (t[q].len == t[p].len + 1) {
                return q;
            }
            int r = newNode();
            t[r].len = t[p].len + 1;
            t[r].link = t[q].link;
            t[r].next = t[q].next;
            t[q].link = r;
            while (t[p].next[c] == q) {
                t[p].next[c] = r;
                p = t[p].link;
            }
            return r;
        }
        int cur = newNode();
        t[cur].len = t[p].len + 1;
        while (!t[p].next[c]) {
            t[p].next[c] = cur;
            p = t[p].link;
        }
        t[cur].link = extend(p, c);
        return cur;
    }
};
std::vector<int> manacher(std::string s) {
    int n = s.size();
    std::vector<int> r(n);
    for (int i = 0, j = 0; i < n; i++) {
        if (2 * j - i >= 0 && j + r[j] > i) {
            r[i] = std::min(r[2 * j - i], j + r[j] - i);
        }
        while (i - r[i] >= 0 && i + r[i] < n && s[i - r[i]] == s[i + r[i]]) {
            r[i] += 1;
        }
        if (i + r[i] > j + r[j]) {
            j = i;
        }
    }
    return r;
}
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        std::string s;
    std::cin >> s;
        int n = s.size();
        auto t = s;
    std::reverse(s.begin(), s.end());
        auto r = manacher(s);
        int len = 0;
    std::vector<std::pair<int, int>> ans;
        SAM sam;
    std::vector<int> f(n + 1);
    f[0] = 1;
    for (int i = 0; i < n; i++) {
        f[i + 1] = sam.extend(f[i], t[i] - 'a');
    }
        std::vector<int> fst(sam.t.size(), n);
    for (int i = 1; i <= n; i++) {
        fst[f[i]] = i;
    }
    std::vector<std::vector<int>> adj(sam.t.size());
    for (int i = 2; i < sam.t.size(); i++) {
        adj[sam.t[i].link].push_back(i);
    }
    std::function<void(int)> dfs = [&](int x) {
        for (auto y : adj[x]) {
            dfs(y);
            fst[x] = std::min(fst[x], fst[y]);
        }
    };
    dfs(1);
        std::vector<std::vector<int>> cand(n + 1);
    for (int i = 0; i < n; i++) {
        int L = i - (r[i] - 1);
        int R = i + r[i];
                if (R - L > len) {
            len = R - L;
            ans = {{n - R + 1, R - L}};
        }
        cand[L].push_back(R);
    }
        std::vector<int> stk;
    std::vector<int> lastl(n + 1);
    for (int i = 0, p = 1; i < n; i++) {
        if (!sam.t[p].next[s[i] - 'a']) {
            break;
        }
        p = sam.t[p].next[s[i] - 'a'];
        lastl[i + 1] = n - fst[p];
    }
    for (int i = 0; i < n; i++) {
        int L = i;
        for (auto R : cand[L]) {
            auto it = std::partition_point(stk.begin(), stk.end(), [&](int x) {
                return lastl[x] >= R;
            });
                        if (it != stk.begin()) {
                int x = *(it - 1);
                if (x * 2 + R - L > len) {
                    len = x * 2 + R - L;
                    ans = {{n - lastl[x] - x + 1, x}, {n - R + 1, R - L}, {n - x + 1, x}};
                }
            }
        }
        while (!stk.empty() && lastl[i + 1] > lastl[stk.back()]) {
            stk.pop_back();
        }
        stk.push_back(i + 1);
    }
        std::cout << ans.size() << "\n";
    for (auto [x, l] : ans) {
        std::cout << x << " " << l << "\n";
    }
        return 0;
}