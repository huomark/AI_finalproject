#include <bits/stdc++.h>
 using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using u128 = unsigned __int128;
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
        Fenwick(int n_ = 0) {
        init(n_);
    }
        void init(int n_) {
        n = n_;
        a.assign(n, T{});
    }
        void add(int x, const T &v) {
        for (int i = x + 1; i <= n; i += i & -i) {
            a[i - 1] = a[i - 1] + v;
        }
    }
        T sum(int x) {
        T ans{};
        for (int i = x; i > 0; i -= i & -i) {
            ans = ans + a[i - 1];
        }
        return ans;
    }
        T rangeSum(int l, int r) {
        return sum(r) - sum(l);
    }
        int select(const T &k) {
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && cur + a[x + i - 1] <= k) {
                x += i;
                cur = cur + a[x - 1];
            }
        }
        return x;
    }
};
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, m0, k0, q;
    std::cin >> n >> m0 >> k0 >> q;
        std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
        auto val = a;
        std::vector<std::array<int, 5>> qry(q);
    for (int i = 0; i < q; i++) {
        int o;
        std::cin >> o;
                if (o == 1) {
            int m, k, x;
            std::cin >> m >> k >> x;
            x--;
            qry[i] = {1, m, k, x};
        } else if (o == 2) {
            int p, v;
            std::cin >> p >> v;
            p--;
            qry[i] = {2, p, v};
            val.push_back(v);
        } else {
            int m, k, l, r;
            std::cin >> m >> k >> l >> r;
            l--;
            qry[i] = {3, m, k, l, r};
        }
    }
        std::sort(val.begin(), val.end());
        val.erase(std::unique(val.begin(), val.end()), val.end());
    const int V = val.size();
        Fenwick<int> fc(V);
    Fenwick<i64> fs(V);
        for (int i = 0; i < n; i++) {
        a[i] = std::lower_bound(val.begin(), val.end(), a[i]) - val.begin();
        fc.add(a[i], 1);
        fs.add(a[i], val[a[i]]);
    }
        auto get = [&](int m, int k) -> std::array<int, 4> {
        int lo = -2E9 - 1, hi = 1E9 + 1;
        while (lo < hi) {
            int t = std::midpoint(lo, hi + 1);
            int r = std::upper_bound(val.begin(), val.end(), t + m) - val.begin();
            int l = std::upper_bound(val.begin(), val.end(), t) - val.begin();
            i64 sum = 1LL * m * fc.rangeSum(r, V) + fs.rangeSum(l, r) - 1LL * t * fc.rangeSum(l, r);
            if (sum >= 1LL * m * k) {
                lo = t;
            } else {
                hi = t - 1;
            }
        }
        int t = lo;
        int R = std::upper_bound(val.begin(), val.end(), t + m) - val.begin();
        int L = std::upper_bound(val.begin(), val.end(), t) - val.begin();
        i64 sum = 1LL * m * fc.rangeSum(R, V) + fs.rangeSum(L, R) - 1LL * t * fc.rangeSum(L, R);
        L = fc.sum(L);
        R = fc.sum(R);
        int M = R - (sum - 1LL * m * k);
        return {t, L, M, R};
    };
        auto query = [&](int m, int k, int x) {
        auto [t, L, M, R] = get(m, k);
        // std::cerr << "(" << t << ", " << L << ", " << M << ", " << R << ")\n";
        if (x >= R) {
            return val[fc.select(x)] - m;
        } else if (x < L) {
            return val[fc.select(x)];
        } else {
            return t + (x >= M);
        }
    };
        {
        auto [t, L, M, R] = get(m0, k0);
        for (int x = 0; x < n; x++) {
            int res;
            if (x >= R) {
                res = val[fc.select(x)] - m0;
            } else if (x < L) {
                res = val[fc.select(x)];
            } else {
                res = t + (x >= M);
            }
            std::cout << res << " \n"[x == n - 1];
        }
    }
        auto getPre = [&](int n) {
        int x = fc.select(n);
        int c = fc.sum(x);
        i64 ans = fs.sum(x);
        if (c < n) {
            ans += 1LL * val[x] * (n - c);
        }
        return ans;
    };
        auto getSum = [&](int l, int r) {
        return getPre(r) - getPre(l);
    };
        for (int i = 0; i < q; i++) {
        if (qry[i][0] == 1) {
            auto [_, m, k, x, _1] = qry[i];
            std::cout << query(m, k, x) << "\n";
        } else if (qry[i][0] == 2) {
            auto [_, p, v, _1, _2] = qry[i];
            v = std::lower_bound(val.begin(), val.end(), v) - val.begin();
            fc.add(a[p], -1);
            fs.add(a[p], -val[a[p]]);
            a[p] = v;
            fc.add(v, 1);
            fs.add(v, val[v]);
        } else {
            auto [_, m, k, l, r] = qry[i];
            auto [t, L, M, R] = get(m, k);
                        i64 ans = 0;
                        int lo = std::max(l, 0);
            int hi = std::min(r, L);
            if (lo < hi) {
                ans += getSum(lo, hi);
            }
                        lo = std::max(l, L);
            hi = std::min(r, M);
            if (lo < hi) {
                ans += 1LL * t * (hi - lo);
            }
                        lo = std::max(l, M);
            hi = std::min(r, R);
            if (lo < hi) {
                ans += 1LL * (t + 1) * (hi - lo);
            }
                        lo = std::max(l, R);
            hi = std::min(r, n);
            if (lo < hi) {
                ans += getSum(lo, hi) - 1LL * m * (hi - lo);
            }
                        std::cout << ans << "\n";
        }
    }
        return 0;
}