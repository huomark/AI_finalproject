#include <bits/stdc++.h>
 using i64 = long long;
 constexpr i64 inf = 1E18;
 template<class T>
struct Point {
    T x;
    T y;
    Point(const T &x_ = 0, const T &y_ = 0) : x(x_), y(y_) {}
        template<class U>
    operator Point<U>() {
        return Point<U>(U(x), U(y));
    }
    Point &operator+=(const Point &p) & {
        x += p.x;
        y += p.y;
        return *this;
    }
    Point &operator-=(const Point &p) & {
        x -= p.x;
        y -= p.y;
        return *this;
    }
    Point &operator*=(const T &v) & {
        x *= v;
        y *= v;
        return *this;
    }
    Point &operator/=(const T &v) & {
        x /= v;
        y /= v;
        return *this;
    }
    Point operator-() const {
        return Point(-x, -y);
    }
    friend Point operator+(Point a, const Point &b) {
        return a += b;
    }
    friend Point operator-(Point a, const Point &b) {
        return a -= b;
    }
    friend Point operator*(Point a, const T &b) {
        return a *= b;
    }
    friend Point operator/(Point a, const T &b) {
        return a /= b;
    }
    friend Point operator*(const T &a, Point b) {
        return b *= a;
    }
    friend bool operator==(const Point &a, const Point &b) {
        return a.x == b.x && a.y == b.y;
    }
    friend std::istream &operator>>(std::istream &is, Point &p) {
        return is >> p.x >> p.y;
    }
    friend std::ostream &operator<<(std::ostream &os, const Point &p) {
        return os << "(" << p.x << ", " << p.y << ")";
    }
};
 template<class T>
struct Line {
    Point<T> a;
    Point<T> b;
    Line(const Point<T> &a_ = Point<T>(), const Point<T> &b_ = Point<T>()) : a(a_), b(b_) {}
};
 template<class T>
T dot(const Point<T> &a, const Point<T> &b) {
    return a.x * b.x + a.y * b.y;
}
 template<class T>
T cross(const Point<T> &a, const Point<T> &b) {
    return a.x * b.y - a.y * b.x;
}
 template<class T>
T square(const Point<T> &p) {
    return dot(p, p);
}
 template<class T>
double length(const Point<T> &p) {
    return std::sqrt(square(p));
}
 template<class T>
double length(const Line<T> &l) {
    return length(l.a - l.b);
}
 template<class T>
Point<T> normalize(const Point<T> &p) {
    return p / length(p);
}
 template<class T>
bool parallel(const Line<T> &l1, const Line<T> &l2) {
    return cross(l1.b - l1.a, l2.b - l2.a) == 0;
}
 template<class T>
double distance(const Point<T> &a, const Point<T> &b) {
    return length(a - b);
}
 template<class T>
double distancePL(const Point<T> &p, const Line<T> &l) {
    return std::abs(cross(l.a - l.b, l.a - p)) / length(l);
}
 template<class T>
double distancePS(const Point<T> &p, const Line<T> &l) {
    if (dot(p - l.a, l.b - l.a) < 0) {
        return distance(p, l.a);
    }
    if (dot(p - l.b, l.a - l.b) < 0) {
        return distance(p, l.b);
    }
    return distancePL(p, l);
}
 template<class T>
Point<T> rotate(const Point<T> &a) {
    return Point(-a.y, a.x);
}
 template<class T>
int sgn(const Point<T> &a) {
    return a.y > 0 || (a.y == 0 && a.x > 0) ? 1 : -1;
}
 template<class T>
bool pointOnLineLeft(const Point<T> &p, const Line<T> &l) {
    return cross(l.b - l.a, p - l.a) > 0;
}
 template<class T>
Point<T> lineIntersection(const Line<T> &l1, const Line<T> &l2) {
    return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));
}
 template<class T>
bool pointOnSegment(const Point<T> &p, const Line<T> &l) {
    return cross(p - l.a, l.b - l.a) == 0 && std::min(l.a.x, l.b.x) <= p.x && p.x <= std::max(l.a.x, l.b.x)
        && std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y);
}
 template<class T>
bool pointInPolygon(const Point<T> &a, const std::vector<Point<T>> &p) {
    int n = p.size();
    for (int i = 0; i < n; i++) {
        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {
            return true;
        }
    }
        int t = 0;
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line(v, u))) {
            t ^= 1;
        }
        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line(u, v))) {
            t ^= 1;
        }
    }
        return t == 1;
}
 // 0 : not intersect
// 1 : strictly intersect
// 2 : overlap
// 3 : intersect at endpoint
template<class T>
std::tuple<int, Point<T>, Point<T>> segmentIntersection(const Line<T> &l1, const Line<T> &l2) {
    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {
        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {
            return {0, Point<T>(), Point<T>()};
        } else {
            auto maxx1 = std::max(l1.a.x, l1.b.x);
            auto minx1 = std::min(l1.a.x, l1.b.x);
            auto maxy1 = std::max(l1.a.y, l1.b.y);
            auto miny1 = std::min(l1.a.y, l1.b.y);
            auto maxx2 = std::max(l2.a.x, l2.b.x);
            auto minx2 = std::min(l2.a.x, l2.b.x);
            auto maxy2 = std::max(l2.a.y, l2.b.y);
            auto miny2 = std::min(l2.a.y, l2.b.y);
            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));
            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));
            if (!pointOnSegment(p1, l1)) {
                std::swap(p1.y, p2.y);
            }
            if (p1 == p2) {
                return {3, p1, p2};
            } else {
                return {2, p1, p2};
            }
        }
    }
    auto cp1 = cross(l2.a - l1.a, l2.b - l1.a);
    auto cp2 = cross(l2.a - l1.b, l2.b - l1.b);
    auto cp3 = cross(l1.a - l2.a, l1.b - l2.a);
    auto cp4 = cross(l1.a - l2.b, l1.b - l2.b);
        if ((cp1 > 0 && cp2 > 0) || (cp1 < 0 && cp2 < 0) || (cp3 > 0 && cp4 > 0) || (cp3 < 0 && cp4 < 0)) {
        return {0, Point<T>(), Point<T>()};
    }
        Point p = lineIntersection(l1, l2);
    if (cp1 != 0 && cp2 != 0 && cp3 != 0 && cp4 != 0) {
        return {1, p, p};
    } else {
        return {3, p, p};
    }
}
 template<class T>
double distanceSS(const Line<T> &l1, const Line<T> &l2) {
    if (std::get<0>(segmentIntersection(l1, l2)) != 0) {
        return 0.0;
    }
    return std::min({distancePS(l1.a, l2), distancePS(l1.b, l2), distancePS(l2.a, l1), distancePS(l2.b, l1)});
}
 template<class T>
bool segmentInPolygon(const Line<T> &l, const std::vector<Point<T>> &p) {
    int n = p.size();
    if (!pointInPolygon(l.a, p)) {
        return false;
    }
    if (!pointInPolygon(l.b, p)) {
        return false;
    }
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        auto w = p[(i + 2) % n];
        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));
                if (t == 1) {
            return false;
        }
        if (t == 0) {
            continue;
        }
        if (t == 2) {
            if (pointOnSegment(v, l) && v != l.a && v != l.b) {
                if (cross(v - u, w - v) > 0) {
                    return false;
                }
            }
        } else {
            if (p1 != u && p1 != v) {
                if (pointOnLineLeft(l.a, Line(v, u))
                    || pointOnLineLeft(l.b, Line(v, u))) {
                    return false;
                }
            } else if (p1 == v) {
                if (l.a == v) {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, l)
                            && pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l)
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else if (l.b == v) {
                    if (pointOnLineLeft(u, Line(l.b, l.a))) {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            && pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, Line(l.b, l.a))
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l)
                            || pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}
 template<class T>
std::vector<Point<T>> hp(std::vector<Line<T>> lines) {
    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {
        auto d1 = l1.b - l1.a;
        auto d2 = l2.b - l2.a;
                if (sgn(d1) != sgn(d2)) {
            return sgn(d1) == 1;
        }
                return cross(d1, d2) > 0;
    });
        std::deque<Line<T>> ls;
    std::deque<Point<T>> ps;
    for (auto l : lines) {
        if (ls.empty()) {
            ls.push_back(l);
            continue;
        }
                while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {
            ps.pop_back();
            ls.pop_back();
        }
                while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {
            ps.pop_front();
            ls.pop_front();
        }
                if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {
                                if (!pointOnLineLeft(ls.back().a, l)) {
                    assert(ls.size() == 1);
                    ls[0] = l;
                }
                continue;
            }
            return {};
        }
                ps.push_back(lineIntersection(ls.back(), l));
        ls.push_back(l);
    }
        while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {
        ps.pop_back();
        ls.pop_back();
    }
    if (ls.size() <= 2) {
        return {};
    }
    ps.push_back(lineIntersection(ls[0], ls.back()));
        return std::vector(ps.begin(), ps.end());
}
 using P = Point<i64>;
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n;
    std::cin >> n;
        std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
        std::vector<i64> s(n + 1);
    for (int i = 0; i < n; i++) {
        s[i + 1] = s[i] + a[i];
    }
        std::vector<std::vector<P>> hi(4 * (n + 1)), lo(4 * (n + 1));
    auto build = [&](auto self, int p, int l, int r) -> void {
        auto &Hi = hi[p], &Lo = lo[p];
        for (int i = l; i < r; i++) {
            P p(i, s[i]);
            while (Hi.size() > 1 && pointOnLineLeft(p, Line(Hi[Hi.size() - 2], Hi.back()))) {
                Hi.pop_back();
            }
            Hi.push_back(p);
            while (Lo.size() > 1 && !pointOnLineLeft(p, Line(Lo[Lo.size() - 2], Lo.back()))) {
                Lo.pop_back();
            }
            Lo.push_back(p);
        }
        if (r - l == 1) {
            return;
        }
        int m = (l + r) / 2;
        self(self, 2 * p, l, m);
        self(self, 2 * p + 1, m, r);
    };
    build(build, 1, 0, n + 1);
        auto query = [&](auto self, int p, int l, int r, int x, int y, P z, int type) -> std::pair<i64, int> {
        if (l >= y || r <= x) {
            return {inf, -1};
        }
        if (l >= x && r <= y) {
            auto &v = (type == 0 ? lo[p] : hi[p]);
            int lo = 0, hi = v.size() - 1;
            while (lo < hi) {
                int m = (lo + hi) / 2;
                if (!pointOnLineLeft(z, Line(v[m], v[m + 1]))) {
                    lo = m + 1;
                } else {
                    hi = m;
                }
            }
            i64 dy = z.y - v[lo].y;
            i64 dx = z.x - v[lo].x;
            if (dx < 0) {
                dy *= -1;
                dx *= -1;
            }
                        return {(dx + dy) / dx, v[lo].x};
        }
        int m = (l + r) / 2;
        return std::min(self(self, 2 * p, l, m, x, y, z, type),
            self(self, 2 * p + 1, m, r, x, y, z, type));
    };
    auto getMax = [&](auto self, int p, int l, int r, int x, int y, i64 d) -> std::pair<i64, int> {
        if (l >= y || r <= x) {
            return {-inf, -1};
        }
        if (l >= x && r <= y) {
            auto &v = hi[p];
            int lo = 0, hi = v.size() - 1;
            P q(-d, 1);
            while (lo < hi) {
                int m = (lo + hi) / 2;
                if (dot(v[m + 1] - v[m], q) >= 0) {
                    lo = m + 1;
                } else {
                    hi = m;
                }
            }
                        return {dot(v[lo], q), v[lo].x};
        }
        int m = (l + r) / 2;
        return std::max(self(self, 2 * p, l, m, x, y, d),
            self(self, 2 * p + 1, m, r, x, y, d));
    };
    auto getMin = [&](auto self, int p, int l, int r, int x, int y, i64 d) -> std::pair<i64, int> {
        if (l >= y || r <= x) {
            return {inf, -1};
        }
        if (l >= x && r <= y) {
            auto &v = lo[p];
            int lo = 0, hi = v.size() - 1;
            P q(-d, 1);
            while (lo < hi) {
                int m = (lo + hi) / 2;
                if (dot(v[m + 1] - v[m], q) < 0) {
                    lo = m + 1;
                } else {
                    hi = m;
                }
            }
                        return {dot(v[lo], q), v[lo].x};
        }
        int m = (l + r) / 2;
        return std::min(self(self, 2 * p, l, m, x, y, d),
            self(self, 2 * p + 1, m, r, x, y, d));
    };
        i64 ans = 0;
    auto work = [&](auto self, int l, int r, i64 d) -> void {
        if (r - l == 1) {
            ans += std::max(0LL, a[l] - d + 1);
            return;
        }
                auto max = getMax(getMax, 1, 0, n + 1, l, r + 1, d);
        auto min = getMin(getMin, 1, 0, n + 1, l, r + 1, d);
        if (max.second != r) {
            if (max.second == l) {
                self(self, l + 1, r, d);
            } else {
                self(self, l, max.second, d);
                self(self, max.second, r, d);
            }
            return;
        }
        if (min.second != l) {
            if (min.second == r) {
                self(self, l, r - 1, d);
            } else {
                self(self, l, min.second, d);
                self(self, min.second, r, d);
            }
            return;
        }
        auto v = std::min(query(query, 1, 0, n + 1, l + 1, r, P(l, s[l]), 0),
            query(query, 1, 0, n + 1, l + 1, r, P(r, s[r]), 1));
        i64 nd = std::max(d, v.first);
        ans += nd - d;
        self(self, l, r, nd);
    };
    work(work, 0, n, 0LL);
        std::cout << ans << "\n";
        return 0;
}   