#include <bits/stdc++.h>
 using i64 = long long;
struct DSU {
    std::vector<int> f, siz;
        DSU() {}
    DSU(int n) {
        init(n);
    }
        void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
        int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
        bool same(int x, int y) {
        return find(x) == find(y);
    }
        bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
        int size(int x) {
        return siz[find(x)];
    }
};
template<class Info>
struct SegmentTree {
    int n;
    std::vector<Info> info;
    SegmentTree() : n(0) {}
    SegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    SegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {
        init(std::vector(n_, v_));
    }
    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(4 << std::__lg(n), Info());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n, l, r);
    }
    template<class F>
    int findFirst(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 0, n, l, r, pred);
    }
    template<class F>
    int findLast(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 0, n, l, r, pred);
    }
};
 constexpr i64 inf = 1E18;
 struct Info {
    i64 cnt = 0;
    i64 sum = 0;
    i64 min = inf;
};
 Info operator+(Info a, Info b) {
    Info c;
    c.cnt = a.cnt + b.cnt;
    c.sum = a.sum + b.sum;
    c.min = std::min(a.min, b.min);
    return c;
}
 void solve() {
    int n;
    std::cin >> n;
        std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
        std::map<int, int> l, r;
    for (int i = 0; i < n; i++) {
        if (!l.count(a[i])) {
            l[a[i]] = i;
        }
        r[a[i]] = i;
    }
        std::vector<std::array<int, 3>> e;
    std::vector<int> b(n);
    for (auto [x, lx] : l) {
        e.push_back({x, lx, r[x]});
    }
    std::reverse(e.begin(), e.end());
        std::map<int, int> f;
    std::vector<std::array<int, 3>> v;
    DSU dsu(n + 1);
    std::vector<bool> fix(n);
    for (auto [x, l, r] : e) {
        auto it = f.lower_bound(l);
        if (it != f.end() && it->second < r) {
            continue;
        }
        v.push_back({x, l, r});
        dsu.merge(l + 1, l);
        dsu.merge(r + 1, r);
        fix[l] = fix[r] = true;
        b[l] = b[r] = x;
        f[l] = r;
        it--;
        while (it != f.begin() && std::prev(it)->second > r) {
            f.erase(std::prev(it));
        }
    }
        for (auto [x, l, r] : v) {
        for (int i = dsu.find(l); i <= r; i = dsu.find(i)) {
            dsu.merge(i + 1, i);
            b[i] = x;
        }
    }
    i64 ans = -1;
    i64 sum = std::accumulate(b.begin(), b.end(), 0LL);
    if (std::count(b.begin(), b.end(), 0) == 0) {
        ans = sum;
    }
    int lz = n, rz = -1;
    for (int i = 0; i < n; i++) {
        if (b[i] == 0) {
            lz = std::min(lz, i);
            rz = i;
        }
    }
    std::vector<int> p(n);
    std::iota(p.begin(), p.end(), 0);
    std::sort(p.begin(), p.end(), [&](int i, int j) {
        return b[i] > b[j];
    });
    SegmentTree<Info> seg(n);
    for (int i = 0; i < n; i++) {
        if (!fix[i]) {
            seg.modify(i, {1, b[i], b[i]});
        }
    }
    int Val = -1;
    int Lv = -1, Rv = -1;
    for (int i = 0, j = 0, k = 0; i < v.size(); i++) {
        auto [x, l, r] = v[i];
        if (j < i) {
            j = i;
        }
        while (j + 1 < v.size() && v[j][0] - 1 == v[j + 1][0]) {
            j++;
        }
        int val = v[j][0] - 1;
        if (val == 0) {
            continue;
        }
        while (k < n && b[p[k]] > val) {
            if (!fix[p[k]]) {
                seg.modify(p[k], {0, 0, b[p[k]]});
            }
            k++;
        }
        int lv = std::min(l, lz);
        int rv = std::max(r, rz);
        i64 res = sum;
        auto info = seg.rangeQuery(0, lv + 1);
        if (info.cnt) {
            res += 1LL * info.cnt * val - info.sum;
        } else {
            res += val - info.min;
        }
        info = seg.rangeQuery(rv, n);
        if (info.cnt) {
            res += 1LL * info.cnt * val - info.sum;
        } else {
            res += val - info.min;
        }
        if (lv < rv) {
            info = seg.rangeQuery(lv + 1, rv);
            res += 1LL * info.cnt * val - info.sum;
        }
        if (res > ans) {
            ans = res;
            Val = val;
            Lv = lv;
            Rv = rv;
        }
    }
    if (Val != -1) {
        int x = -1;
        bool lt = false;
        for (int i = Lv; i >= 0; i--) {
            if (!fix[i]) {
                if (b[i] < Val) {
                    b[i] = Val;
                    lt = true;
                } else {
                    if (x == -1 || b[i] < b[x]) {
                        x = i;
                    }
                }
            }
        }
        if (!lt) {
            b[x] = Val;
        }
        x = -1;
        lt = false;
        for (int i = Rv; i < n; i++) {
            if (!fix[i]) {
                if (b[i] < Val) {
                    b[i] = Val;
                    lt = true;
                } else {
                    if (x == -1 || b[i] < b[x]) {
                        x = i;
                    }
                }
            }
        }
        if (!lt) {
            b[x] = Val;
        }
        for (int i = Lv + 1; i < Rv; i++) {
            if (!fix[i] && b[i] < Val) {
                b[i] = Val;
            }
        }
    }
    for (int i = 0; i < n; i++) {
        std::cout << b[i] << " \n"[i == n - 1];
    }
}
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int t;
    std::cin >> t;
        while (t--) {
        solve();
    }
        return 0;
}