#include <bits/stdc++.h>
 using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using u128 = unsigned __int128;
using i128 = __int128;
 struct DSU {
    std::vector<int> siz, f;
    std::vector<std::pair<int *, int>> his;
    DSU(int n) : siz(n, 1), f(n) { std::iota(f.begin(), f.end(), 0); }
    bool merge(int u, int v) {
        u = find(u), v = find(v);
        if (u == v) return false;
        if (siz[u] < siz[v]) std::swap(u, v);
        his.emplace_back(&siz[u], siz[u]);
        siz[u] += siz[v];
        his.emplace_back(&f[v], f[v]);
        f[v] = u;
        return true;
    }
    int find(int x) {
        while (x != f[x]) x = f[x];
        return x;
    }
    int size(int x) { return siz[find(x)]; }
    void undo(int x) {
        while (int(his.size()) > x) {
            *his.back().first = his.back().second;
            his.pop_back();
        }
    }
};
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int n, q;
    std::cin >> n >> q;
        std::map<std::array<int, 2>, int> edges[2];
        std::vector<std::vector<std::array<int, 3>>> f(4 * q);
        auto addEdge = [&](this auto &&self, int p, int l, int r, int x, int y, int t, int u, int v) {
        if (l >= y || r <= x) {
            return;
        }
        if (l >= x && r <= y) {
            f[p].push_back({t, u, v});
            return;
        }
        int m = (l + r) / 2;
        self(2 * p, l, m, x, y, t, u, v);
        self(2 * p + 1, m, r, x, y, t, u, v);
    };
    for (int i = 0; i < q; i++) {
        char g;
        std::cin >> g;
        int u, v;
        std::cin >> u >> v;
        u--;
        v--;
        if (u > v) {
            std::swap(u, v);
        }
        int t = g - 'A';
        if (edges[t].contains({u, v})) {
            addEdge(1, 0, q, edges[t][{u, v}], i, t, u, v);
            edges[t].erase({u, v});
        } else {
            edges[t][{u, v}] = i;
        }
    }
        for (int t = 0; t < 2; t++) {
        for (auto [e, i] : edges[t]) {
            auto [u, v] = e;
            addEdge(1, 0, q, i, q, t, u, v);
        }
    }
        DSU dsu[2] {n, n};
    auto work = [&](this auto &&self, int p, int l, int r, int A, int B) -> void {
        int tm[2] = {int(dsu[0].his.size()), int(dsu[1].his.size())};
        for (auto [t, u, v] : f[p]) {
            A -= dsu[0].merge(u, v);
            if (!t) {
                B -= dsu[1].merge(u, v);
            }
        }
        if (r - l == 1) {
            std::cout << B - A << "\n";
        } else {
            int m = (l + r) / 2;
            self(2 * p, l, m, A, B);
            self(2 * p + 1, m, r, A, B);
        }
        for (int t = 0; t < 2; t++) {
            dsu[t].undo(tm[t]);
        }
    };
    work(1, 0, q, n, n);
        return 0;
}