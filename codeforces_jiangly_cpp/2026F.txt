#include <bits/stdc++.h>
 using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using u128 = unsigned __int128;
 constexpr int P = 2000;
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int q;
    std::cin >> q;
        std::vector<int> cur {0};
    std::vector<std::array<int, 2>> op(1);
    std::vector<std::vector<std::array<int, 2>>> ask(1);
    std::vector<std::vector<int>> adj(1);
        int qs = 0;
    std::vector<int> ans;
        for (int i = 0; i < q; i++) {
        int o;
        std::cin >> o;
                if (o == 1) {
            int x;
            std::cin >> x;
            x--;
                        cur.push_back(cur[x]);
        } else if (o == 2) {
            int x, p, t;
            std::cin >> x >> p >> t;
            x--;
                        int y = op.size();
            op.push_back({p, t});
            ask.push_back({});
            adj.push_back({});
            adj[cur[x]].push_back(y);
            cur[x] = y;
        } else if (o == 3) {
            int x;
            std::cin >> x;
            x--;
                        int y = op.size();
            op.push_back({-1, -1});
            ask.push_back({});
            adj.push_back({});
            adj[cur[x]].push_back(y);
            cur[x] = y;
        } else {
            int x, p;
            std::cin >> x >> p;
            x--;
                        ask[cur[x]].push_back({p, qs});
            qs++;
        }
    }
        ans.resize(qs);
        std::deque<std::array<int, 2>> dq;
    std::vector<std::vector<int>> L(1, std::vector<int>(P + 1)), R(1, std::vector<int>(P + 1));
        auto add = [&](std::vector<int> a, int p, int t) {
        for (int i = P; i >= p; i--) {
            a[i] = std::max(a[i], a[i - p] + t);
        }
        return a;
    };
        auto rebuild = [&] {
        int m = dq.size();
        int l = m / 2;
        int r = m - l;
        L.assign(l + 1, std::vector<int>(P + 1));
        R.assign(r + 1, std::vector<int>(P + 1));
        for (int i = 0; i < l; i++) {
            auto [p, t] = dq[l - 1 - i];
            L[i + 1] = add(L[i], p, t);
        }
        for (int i = 0; i < r; i++) {
            auto [p, t] = dq[l + i];
            R[i + 1] = add(R[i], p, t);
        }
    };
        auto pushBack = [&](int p, int t) {
        dq.push_back({p, t});
        R.push_back(add(R.back(), p, t));
    };
        auto popBack = [&] {
        assert(!dq.empty());
        dq.pop_back();
        if (R.size() > 1) {
            R.pop_back();
        } else {
            rebuild();
        }
    };
        auto pushFront = [&](int p, int t) {
        dq.push_front({p, t});
        L.push_back(add(L.back(), p, t));
    };
        auto popFront = [&] {
        assert(!dq.empty());
        dq.pop_front();
        if (L.size() > 1) {
            L.pop_back();
        } else {
            rebuild();
        }
    };
        auto query = [&](int p) {
        int ans = 0;
        for (int i = 0; i <= p; i++) {
            ans = std::max(ans, L.back()[i] + R.back()[p - i]);
        }
        return ans;
    };
        auto dfs = [&](this auto &&self, int x) -> void {
        int p, t;
        if (x) {
            std::tie(p, t) = op[x];
            if (p > 0) {
                pushBack(p, t);
            } else {
                std::tie(p, t) = dq.front();
                popFront();
                p = -p;
            }
        }
                for (auto [p, i] : ask[x]) {
            ans[i] = query(p);
        }
                for (auto y : adj[x]) {
            self(y);
        }
                if (x) {
            if (p > 0) {
                popBack();
            } else {
                pushFront(-p, t);
            }
        }
    };
    dfs(0);
        for (int i = 0; i < qs; i++) {
        std::cout << ans[i] << "\n";
    }
        return 0;
}