#include <bits/stdc++.h>
 using u32 = unsigned;
using i64 = long long;
using u64 = unsigned long long;
 constexpr int N = 1 << 18;
 struct Node {
    std::pair<i64, int> max;
    i64 sum;
    int ans;
} t[2 * N];
 int node(int l, int r) {
    if (r - l == 1) {
        return l * 2 + 1;
    }
    return l + r;
}
 std::pair<std::pair<i64, int>, i64> rangeQuery(int l, int r) {
    std::pair<i64, int> max {-1, -1};
    i64 sum = 0;
    while (l < r) {
        int p;
        if ((r & (r - 1)) >= l) {
            p = node(r & (r - 1), r);
            r &= r - 1;
        } else {
            assert(l + (l & -l) <= r);
            p = node(l, l + (l & -l));
            l += l & -l;
        }
        max = std::max(max, t[p].max);
        sum += t[p].sum;
    }
    return {max, sum};
}
 int contained(int l, int r, int L, int R) {
    int l1 = std::__lg(l ^ (L - 1));
    int l2 = std::__lg((r - 1) ^ (L - 1));
    int r1 = std::__lg(l ^ R);
    int r2 = std::__lg((r - 1) ^ R);
    if (l1 != l2 || r1 != r2) {
        return -1;
    }
    assert(l1 != r1);
    if (l1 < r1) {
        L--;
        L |= (1 << l1) - 1;
        L++;
        R = L + (1 << l1);
    } else {
        R &= ~((1 << r1) - 1);
        L = R - (1 << r1);
    }
    return node(L, R);
}
 void query(int l, int r, int L, int R, int &ans) {
    if (r - l <= std::max(ans, 2)) {
        return;
    }
    int p = contained(l, r, L, R);
    if (p != -1) {
        ans = std::max(ans, t[p].ans);
        return;
    }
    auto [max, sum] = rangeQuery(l, r);
    if (max.first * 2 < sum) {
        ans = r - l;
        return;
    }
    p = max.second;
    query(l, p, L, R, ans);
    query(p + 1, r, L, R, ans);
}
 void pull(int l, int r) {
    int p = node(l, r);
    int m = (l + r) / 2;
    int pl = node(l, m);
    int pr = node(m, r);
    t[p].max = std::max(t[pl].max, t[pr].max);
    t[p].sum = t[pl].sum + t[pr].sum;
    t[p].ans = std::max(t[pl].ans, t[pr].ans);
        int L = l, R = r;
    while (R - L > std::max(2, t[p].ans)) {
        auto [max, sum] = rangeQuery(L, R);
        if (max.first * 2 < sum) {
            t[p].ans = R - L;
            break;
        }
        int x = max.second;
        if (x < m) {
            L = x + 1;
        } else {
            R = x;
        }
    }
}
 void modify(int i, i64 a, int l = 0, int r = N) {
    if (r - l == 1) {
        int p = node(l, r);
        t[p] = {.max {a, i}, .sum = a, .ans = -1};
        return;
    }
    int m = (l + r) / 2;
    if (i < m) {
        modify(i, a, l, m);
    } else {
        modify(i, a, m, r);
    }
    pull(l, r);
}
 void solve() {
    int n, q;
    std::cin >> n >> q;
        for (int i = 0; i < n; i++) {
        i64 a;
        std::cin >> a;
                modify(i, a);
    }
        for (int i = 0; i < q; i++) {
        int o;
        std::cin >> o;
                if (o == 2) {
            int x;
            i64 y;
            std::cin >> x >> y;
            x--;
            modify(x, y);
        } else {
            int l, r;
            std::cin >> l >> r;
            l--;
            int ans = -1;
            query(l, r, l, r, ans);
            std::cout << ans << "\n";
        }
    }
}
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        for (int i = 0; i < 2 * N; i++) {
        t[i].max = {-1, -1};
    }
        int t;
    std::cin >> t;
        while (t--) {
        solve();
    }
        return 0;
}