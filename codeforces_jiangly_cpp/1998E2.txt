#include <bits/stdc++.h>
 using u32 = unsigned;
using i64 = long long;
using u64 = unsigned long long;
 template<class T,
    class Cmp = std::less<T>>
struct RMQ {
    const Cmp cmp = Cmp();
    static constexpr unsigned B = 64;
    using u64 = unsigned long long;
    int n;
    std::vector<std::vector<T>> a;
    std::vector<T> pre, suf, ini;
    std::vector<u64> stk;
    RMQ() {}
    RMQ(const std::vector<T> &v) {
        init(v);
    }
    void init(const std::vector<T> &v) {
        n = v.size();
        pre = suf = ini = v;
        stk.resize(n);
        if (!n) {
            return;
        }
        const int M = (n - 1) / B + 1;
        const int lg = std::__lg(M);
        a.assign(lg + 1, std::vector<T>(M));
        for (int i = 0; i < M; i++) {
            a[0][i] = v[i * B];
            for (int j = 1; j < B && i * B + j < n; j++) {
                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);
            }
        }
        for (int i = 1; i < n; i++) {
            if (i % B) {
                pre[i] = std::min(pre[i], pre[i - 1], cmp);
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (i % B != B - 1) {
                suf[i] = std::min(suf[i], suf[i + 1], cmp);
            }
        }
        for (int j = 0; j < lg; j++) {
            for (int i = 0; i + (2 << j) <= M; i++) {
                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);
            }
        }
        for (int i = 0; i < M; i++) {
            const int l = i * B;
            const int r = std::min(1U * n, l + B);
            u64 s = 0;
            for (int j = l; j < r; j++) {
                while (s && cmp(v[j], v[std::__lg(s) + l])) {
                    s ^= 1ULL << std::__lg(s);
                }
                s |= 1ULL << (j - l);
                stk[j] = s;
            }
        }
    } 
    T operator()(int l, int r) {
        if (l / B != (r - 1) / B) {
            T ans = std::min(suf[l], pre[r - 1], cmp);
            l = l / B + 1;
            r = r / B;
            if (l < r) {
                int k = std::__lg(r - l);
                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);
            }
            return ans;
        } else {
            int x = B * (l / B);
            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];
        }
    }
};
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
        Fenwick(int n_ = 0) {
        init(n_);
    }
        void init(int n_) {
        n = n_;
        a.assign(n, T{});
    }
        void add(int x, const T &v) {
        for (int i = x + 1; i <= n; i += i & -i) {
            a[i - 1] = a[i - 1] + v;
        }
    }
        T sum(int x) {
        T ans{};
        for (int i = x; i > 0; i -= i & -i) {
            ans = ans + a[i - 1];
        }
        return ans;
    }
        T rangeSum(int l, int r) {
        return sum(r) - sum(l);
    }
        int select(const T &k) {
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && cur + a[x + i - 1] <= k) {
                x += i;
                cur = cur + a[x - 1];
            }
        }
        return x;
    }
};
 void solve() {
    int n, x;
    std::cin >> n >> x;
    x--;
        std::vector<int> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
    }
        std::vector<i64> pre(n + 1);
    for (int i = 0; i < n; i++) {
        pre[i + 1] = pre[i] + a[i];
    }
        RMQ<int, std::greater<int>> maxa {a};
    std::vector<int> f(n);
    std::vector<std::vector<int>> vec(n);
        for (int i = 0; i < n; i++) {
        int l = i, r = i + 1;
        while (true) {
            bool change = false;
            int lo = 0, hi = l;
            i64 sum = pre[r] - pre[l];
            while (lo < hi) {
                int x = (lo + hi) / 2;
                if (maxa(x, l) <= sum) {
                    hi = x;
                } else {
                    lo = x + 1;
                }
            }
            if (l != lo) {
                change = true;
            }
            l = lo;
            lo = r;
            hi = n;
            sum = pre[r] - pre[l];
            while (lo < hi) {
                int x = (lo + hi + 1) / 2;
                if (maxa(r, x) <= sum) {
                    lo = x;
                } else {
                    hi = x - 1;
                }
            }
            if (r != lo) {
                change = true;
            }
            r = lo;
            if (!change) {
                break;
            }
        }
        if (r < n) {
            vec[r].push_back(i);
        }
    }
    Fenwick<int> fen(n);
    std::vector<int> right(n);
    for (int r = 0, l = 0; r < n; r++) {
        for (auto i : vec[r]) {
            fen.add(i, 1);
        }
        int lo = r + 1, hi = n;
        while (lo < hi) {
            int x = (lo + hi + 1) / 2;
            if (pre[x] - pre[r + 1] < a[r]) {
                lo = x;
            } else {
                hi = x - 1;
            }
        }
        right[r] = lo;
        while (right[l] <= r) {
            l++;
        }
        f[r] = l + 1 - fen.sum(l + 1);
    }
    for (int i = x; i < n; i++) {
        std::cout << f[i] << " \n"[i == n - 1];
    }
}
 int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
        int t;
    std::cin >> t;
        while (t--) {
        solve();
    }
        return 0;
}